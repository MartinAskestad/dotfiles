unlet! skip_defaults_vim
source $VIMRUNTIME/defaults.vim

if has('vim_starting')
  " Encoding, changing encoding at runtime is undefined behavior
  if &encoding !=? 'utf-8' | let &termencoding=&encoding | endif
  set encoding=utf-8 fileencoding=utf-8 fileformats=dos,unix
  set fileencodings=utf-8,iso-8859-1
endif

" ## SESSIONS ## {{{
function! s:maybe_save_session() abort
  if v:this_session != ''
    execute 'mksession! ' . v:this_session
  endif
endfunction
" }}}
" ## GIT BRANCH NAME ## {{{
function! s:git_branch_detect(path) abort
  unlet! b:gitbranch_path
  let b:gitbranch_pwd = expand('%:p:h')
  let dir = s:git_branch_dir(a:path)
  if dir !=# ''
    let path = dir . '/HEAD'
    if filereadable(path)
      let b:gitbranch_path = path
    endif
  endif
endfunction

function! s:git_branch_dir(path) abort
  let l:path = a:path
  let l:prev = ''
  let l:git_modules = path =~# '/\.git+modules/'
  while path !=# l:prev
    let l:dir = l:path . '/.git'
    let l:type = getftype(dir)
    if l:type ==# 'dir' && isdirectory(l:dir . '/objects') && isdirectory(dir . '/refs') && getfsize(dir . '/HEAD') > 10
      return l:dir
     elseif type ==# 'file'
       let l:reldir = get(readfile(l:dir), 0, '')
       if l:reldir =~# '^gitdir:'
         return simplify(l:path, '/', l:reldir[8:])
       endif
     elseif l:type ==# 'dir' && isdirectory(l:dir . '/objects') && isdirectory(dir . '/refs') && getfsize(dir . '/HEAD') > 10
       return l:path
     endif
     let l:prev = l:path
     let l:path = fnamemodify(l:path, ':h')
  endwhile
  return ''
endfunction

function! GitBranchName() abort
  if get(b:, 'gitbranch_pwd', '') !=# expand('%:p:h') || !has_key(b:, 'gitbranch_path')
    call s:git_branch_detect(expand('%:p:h'))
  endif
  if has_key(b:, 'gitbranch_path') && filereadable(b:gitbranch_path)
    let l:branch = get(readfile(b:gitbranch_path), 0, '')
    if l:branch =~# '^ref: '
     return substitute(branch, '^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
   elseif l:branch =~# '^\x\{20}'
     return branch[:6]
   endif
 endif
 return ''
endfunction
  " }}}
" ## STATUSLINE ## {{{
let g:mode_labels= {
      \ 'n': 'NORMAL',
      \ 'i': 'INSERT',
      \ 'R': 'REPLACE',
      \ 'v': 'VISUAL',
      \ 'V': 'V-LINE',
      \ "\<C-v>": 'V-BLOCK',
      \ 'c': 'COMMAND',
      \ 's': 'SELECT',
      \ 'S': 'S-LINE',
      \ "\<C-s>": 'S-BLOCK',
      \ 't': 'TERMINAL'
      \ }

function! DisplayFileType() abort
  let l:current_file_type = &ft
  let l:file_types = {
        \ 'typescript': 'ﯤ',
        \ 'vim': '',
        \ 'html': '',
        \ 'scss': '',
        \ }
  let l:file_type = get(l:file_types, &ft, l:current_file_type)
  return l:file_type
endfunction
set statusline=%#User1#
set statusline+=%{get(g:mode_labels,mode(),'')}
set statusline+=%#StatusLine#
set statusline+=\ %{GitBranchName()}
set statusline+=\ %{&modified?'•':''}
set statusline+=%t%=%{DisplayFileType()}\ %{(&fenc!=''?toupper(&fenc):&enc)}\[%{&ff}]\ %3l%2c
" }}}
" ## CUSTOMLISTS ## {{{

function! s:find_buffer() abort
  let l:search = input('buffers: ', '', 'customlist,CompleteBuffers')
  if empty(l:search)
    return
  endif
  let l:bnr = bufwinnr(l:search)
  if l:bnr >= 0
    execute l:bnr . 'wincmd w'
  else
    execute 'b ' . l:search
  endif
endfunction

function! CompleteBuffers(arg, cmd, cur) abort
  let l:buffers =
        \ map(
        \   filter(
        \     range(1, bufnr('$')),
        \     { i, nr -> bufexists(nr) }
        \   ),
        \   { i, nr -> bufname(nr) }
        \ )
  if empty(a:arg)
    return l:buffers
  endif
  return matchfuzzy(l:buffers, a:arg)
endfunction

function! s:find_file() abort
  let l:search = input('files: ', '', 'customlist,CompleteFiles')
  if !empty(l:search)
    execute 'e ' . l:search
  endif
endfunction

function! CompleteFiles(arg, cmd, cur) abort
  " let l:fd_cmd = 'dir /-n /s /b /a-d | findstr /r /v "node_modules \.git \.gz$"'
  let l:fd_cmd = 'fd -t f'
  let l:files = systemlist(l:fd_cmd)
  if empty(a:arg)
    return l:files
  endif
  return matchfuzzy(l:files, a:arg)
endfunction

function! s:find_session() abort
  let l:search = input('sessions: ', '', 'customlist,CompleteSessions')
  if !empty(l:search)
    let l:session = '~/vimfiles/sessions/' . l:search
    execute "source " . l:session
  endif
endfunction

function! CompleteSessions(arg, cmd, cur) abort
  let l:fd_cmd = 'fd -t f -e vim . ' . $HOME . '\vimfiles\sessions'
  let l:session_files = map(systemlist(l:fd_cmd), { i, s -> fnamemodify(s, ':t')})
  if empty(a:arg)
    return l:session_files
  endif
  return matchfuzzy(l:session_files, a:arg)
endfunction

function s:find_npm_script() abort
  let b:package_json_path = lsp#utils#find_nearest_parent_file_directory(getcwd(), ['package.json'])
  if empty(b:package_json_path)
    return
  endif
  let b:package_json_path = b:package_json_path . "\\package.json"
  let l:search = input('npm: ', '', 'customlist,CompleteNpm')
  if !empty(l:search)
    let l:package_json = json_decode(join(readfile(b:package_json_path)))
    let l:npm_script = get(get(l:package_json, 'scripts', {}), l:search, '')
    if !empty(l:npm_script)
      let l:npm_script = "!start cmd /c " . l:npm_script
      silent exe l:npm_script
    endif
  endif
  unlet! b:package_json_path
endfunction

function CompleteNpm(arg, cmd, cur) abort
  let l:package_json = json_decode(join(readfile(b:package_json_path)))
  let l:scripts = get(l:package_json, 'scripts', [])
  if empty(a:arg)
    return keys(l:scripts)
  endif
  return matchfuzzy(keys(l:scripts), a:arg)
endfunction

function s:find_git_branch() abort
  let l:is_git_repo = lsp#utils#find_nearest_parent_file_directory(lsp#utils#get_buffer_path(), ['.git/'])
  echom l:is_git_repo
  if empty(l:is_git_repo)
    return
  endif
  let l:search = input('branch: ', '', 'customlist,CompleteBranches')
  if !empty(l:search)
    if !empty(systemlist('git rev-parse --quiet --verify ' . l:search))
      call system('git checkout ' . l:search)
    else
      call system('git checkout -b ' . l:search)
    endif
  endif
endfunction

function CompleteBranches(arg, cmd, cur) abort
  let l:branches = systemlist('git for-each-ref --format="%(refname:short)" refs/heads/')
  if empty(a:arg)
    return l:branches
  endif
  return matchfuzzy(l:branches, a:arg)
endfunction

def s:select_git_branch()
enddef

command! WildmenuBuffers call s:find_buffer()
command! WildmenuFiles call s:find_file()
command! WildmenuSessions call s:find_session()
command! WildmenuNpm call s:find_npm_script()
command! WildmenuBranches call s:find_git_branch()
" }}}

command! CurrentBufferOnly execute '%bdelete|edit#|bdelete#' 
augroup my_vimrc
  au!
  au! VimEnter,DirChanged * setlocal titlestring=%{&modified?'•':''}%{getcwd()}
  au! BufEnter,VimLeavePre * call <SID>maybe_save_session()
  au! BufLeave,FocusLost,InsertEnter,WinLeave * if &nu | setlocal nornu | endif
  au! BufEnter,FocusGained,InsertLeave,WinEnter * if &nu | setlocal rnu |endif
augroup END

set spell
set spelllang=en_us,sv,cjk

set langmenu=en_US
let $LANG = 'en_US'
source $VIMRUNTIME/delmenu.vim
source $VIMRUNTIME/menu.vim

set background=light
colorscheme mild
hi StatusLine guifg=#503090 guibg=#FFFFFF
hi StatusLineNC guifg=#503090 guibg=#FFCC00 gui=reverse
hi User1 guibg=#503090 guifg=#FFFFFF cterm=bold gui=bold,reverse
hi VertSplit guifg=bg guibg=NONE gui=NONE

" ## Plugins ## {{{
" Turn off default plugins
let g:loaded_2html_plugin=1
let g:loaded_gzip=1
let g:loaded_rrhelper=1
let g:loaded_tar=1
let g:loaded_tarPlugin=1
let g:loaded_vimballPlugin=1
let g:loaded_zip=1
let g:loaded_zipPlugin=1
" Load matchit.vim but only if the user hasn't installed a newer version
if !exists('g:loaded_matchit') && findfile('plugin/matchit.vim', &rtp) ==# ''
  runtime! macros/matchit.vim
endif
" }}}
" ## VIM-LSP/ASYNCOMPLETE ## {{{
let g:lsp_diagnostics_echo_cursor=1
let g:lsp_diagnostics_float_cursor=1
let g:lsp_documentation_float_docked=1
let g:lsp_semantic_enabled=1
let g:lsp_untitled_buffer_enabled=0
let g:asyncomplete_auto_completeopt=0
let g:lsp_settings_filetype_css=['css-languageserver', 'tailwindcss-intellisense']
let g:lsp_settings_filetype_html=['html-languageserver', 'angular-language-server', 'tailwindcss-intellisense']
let g:lsp_settings_filetype_typescript=['typescript-language-server', 'eslint-language-server']
let g:lsp_document_code_action_signs_hint = { 'text': '💡' }
let g:lsp_diagnostics_signs_error = { 'text': '✗' }
let g:lsp_diagnostics_signs_warning = { 'text': '⚠' }
packadd vim-lsp
packadd vim-lsp-settings
packadd asyncomplete.vim
packadd asyncomplete-lsp.vim
set foldmethod=expr
      \ foldexpr=lsp#ui#vim#folding#foldexpr()
      \ foldtext=lsp#ui#vim#folding#foldtext()
set complete&
set completeopt=
set completeopt+=menuone
set completeopt+=noinsert
set completeopt+=preview
set infercase
set pumheight=7
set noshowfulltag
" }}}
" ## VIM-VSNIP ## {{{
packad vim-vsnip
packadd vim-vsnip-integ

let g:vsnip_snippet_dir = expand('$HOME/.local/vim-vsnip')
" }}}

set noeb vb t_vb=
au GUIEnter * set vb t_vb=
