unlet! skip_defaults_vim
source $VIMRUNTIME/defaults.vim

" ## Keyboard bindings ## {{{
" Switch : and . as well as , and ; for easier use on swedish keyboard
let mapleader = " "
nnoremap . :
nnoremap : .
nnoremap , ;
nnoremap ; ,
vnoremap . :
vnoremap : .
vnoremap ; ,
vnoremap , ;

vnoremap p pgvy " paste without overriding current register

nnoremap <Leader>N :nohlsearch<CR>

nnoremap <Leader>T :term<CR>

tnoremap <ESC> <C-w>N

" TABS
nnoremap <Leader>th :tabprevious<CR>
nnoremap <Leader>tj :tabmove -1<CR>
nnoremap <Leader>tk :tabmove +1<CR>
nnoremap <Leader>tl :tabnext<CR>
nnoremap <Leader>tH :tabfirst<CR>
nnoremap <Leader>tL :tablast<CR>
nnoremap <Leader>tq :bdelete<CR>
nnoremap <Leader>tQ :bdelete!<CR>
nnoremap <Leader>to :tabnew<SPACE>
nnoremap <Leader>tx :tabonly<CR>

" Views/Windows
nnoremap <Leader>vw <C-w>w
nnoremap <Leader>vq <C-w>c
nnoremap <Leader>vs <C-w>s
nnoremap <Leader>vv <C-w>v
nnoremap <Leader>vh <C-w>h
nnoremap <Leader>vj <C-w>j
nnoremap <Leader>vk <C-w>k
nnoremap <Leader>vl <C-w>l
nnoremap <Leader>vH <C-w>5<
nnoremap <Leader>vJ <C-w>:resize +5<CR>
nnoremap <Leader>vK <C-w>:resize -5<CR>
nnoremap <Leader>vL <C-w>5>
nnoremap <Leader>vb <C-w>=
nnoremap <Leader>vV <C-w>\|
nnoremap <Leader>vB <C-w>_
nnoremap <Leader>vm <C-w>\|<C-w>_

" Move lines
vnoremap <Leader>mj :m '>+1<CR>gv=gv
vnoremap <Leader>mk :m '<-2<CR>gv=gv
vnoremap <A-j> :m '>+1<CR>gv=gv
vnoremap <A-k> :m '<-2<CR>gv=gv

" Useful insert mode bindings
imap jj <ESC>
inoremap <C-BS> <C-w>
" }}}

" ## Behavior ## {{{
" Encoding
if &encoding !=? 'utf-8' | let &termencoding=&encoding | endif
set encoding=utf-8 fileencoding=utf-8 fileformats=dos,unix
set fileencodings=utf-8,iso-8859-1
" Opening windows and buffer switching
set splitbelow	" New windows appear below
set splitright	" New windows appear to the right
set hidden	" Allow to switch buffers when not saved
set switchbuf=useopen,usetab,newtab
set winminwidth=6	" Set minimum window sizes
set winheight=6
set winminheight=6
set noequalalways
set nowinfixwidth
set nowinfixheight
" Editing
set textwidth=80
set formatoptions=tc    " Wrap text using textwidth
set formatoptions+=r    " Continue comments when enter in insert
set formatoptions+=q    " Enable formating of comments
set formatoptions+=n    " Detect lists for formating
set formatoptions+=b    " Auto wrap in insert mode and no wrapping of old lines
set nojoinspaces
set autoread
set noautowrite
set noautowriteall
set linebreak
set mouse=
set noautochdir
" Searching
set wrapscan
set ignorecase
set smartcase
set incsearch
set hlsearch
set magic
" command line
set wildmenu
set wildchar=9
set wildmode=list:full
set wildoptions=
set wildignorecase
set wildignore=**/node_modules/**,**/dist/**,**/.git/**
" Appearance
set signcolumn=number
set foldcolumn=1
set nu
set rnu
set termguicolors
set background=dark
set display=lastline,uhex
set wrap
set wrapmargin=0
set showmatch
set matchtime=3
set noshowmode
set shortmess+=I
set cmdheight=1
set cmdwinheight=10
set noshowcmd
set rulerformat=
set laststatus=2
set title
set titlelen=100
set titleold=
set titlestring=%f
set noicon
set showtabline=1
set cursorline
set nocursorcolumn
set cursorlineopt=line
set colorcolumn=80
set list listchars=tab:→\ ,eol:¬,nbsp:␣,trail:•,extends:⟩,precedes:⟨ showbreak=↩\
" Performance
set updatetime=300
set lazyredraw
" Diff
set diffopt+=algorithm:patience
set diffopt+=indent-heuristic

set undofile
set undolevels=1000
set undodir=$HOME/vimfiles/undodir
set noswapfile

augroup toggle_line_numbers
	au!
	autocmd BufLeave,FocusLost,InsertEnter,WinLeave *.* if &nu | setlocal nornu | endif
	autocmd BufEnter,FocusGained,InsertLeave,WinEnter *.* if &nu | setlocal rnu | endif
augroup END

" }}}

" ## Plugins ##
" Load matchit.vim but only if the user hasn't installed a newer version.
if !exists('g:loaded_matchit') && findfile('plugin/matchit.vim', &rtp) ==# ''
	runtime! macros/matchit.vim
endif
" ## VIM-POLYGLOT ## {{{
"packadd vim-polyglot
" }}}
" ## EMMET ## {{{
augroup emmet_keyboard_bindings
	au!
	" go to the next opening tag below current line
	nnoremap  <leader>hj 0/$/;/<[a-zA-Z][a-zA-Z0-9]*\%(\_[^>]*>\)\@=<CR>:nohlsearch<CR>
	" go  to the next end of closing tag or empty elenent below current line
	nnoremap  <leader>hJ 0/$/;/\%([^>]*$\)\@=<CR>:nohlsearch<CR>
	" go to the previous closing tag above the current line
	nnoremap  <leader>hk $?^?;?>\%([^>]*$\)\@=<CR>:nohlsearch<CR>
	" go to the previous opening tag above the current line
	nnoremap  <leader>hK $?^?;?^[^z]*\zs<\%([a-zA-Z][a-zA-Z0-9]*\_[^>]*>\)\@=<CR>:nohlsearch<CR>
	" go to the next tag element closing
	nnoremap  <leader>hl /><CR>:nohlsearch<CR>
	" go to the previous tag element opening
	nnoremap  <leader>hh ?<<CR>:nohlsearch<CR>
	" Map emmet to leader keys
	nnoremap <leader>he :call emmet#expandAbbr(3, "")<CR>
	nnoremap <leader>hE :call emmet#expandAbbr(1, "")<CR>
	vnoremap <leader>he :call emmet#expandAbbr(2, "")<CR>
	nnoremap <leader>hn :call emmet#nextPrev(0)<CR>
	nnoremap <leader>hN :call emmet#nextPrev(1)<CR>
	nnoremap <leader>hr :call emmet#removeTag()<CR>
	nnoremap <leader>hu :call emmet#updateTag()<CR>
	" Semantics
	setlocal iskeyword=@,48-57,_,-,\"
	" Navigation
	setlocal suffixesadd+=.html,.css,.txt,.js,.ts,.json
augroup END
let g:user_emmet_install_global = 0
autocmd FileType html,css,scss EmmetInstall
packadd emmet-vim
" }}}
" ## VIM-SURROUND {{{
packadd vim-surround
" }}}
" ## CAMELCASEMOTION ## {{{
packadd CamelCaseMotion
map <silent> w <Plug>CamelCaseMotion_w
map <silent> e <Plug>CamelCaseMotion_e
map <silent> b <Plug>CamelCaseMotion_b
map <silent> ge <Plug>CamelCaseMotion_ge
sunmap w
sunmap e
sunmap b
sunmap ge
omap <silent> iw <Plug>CamelCaseMotion_iw
xmap <silent> iw <Plug>CamelCaseMotion_iw
omap <silent> ie <Plug>CamelCaseMotion_ie
xmap <silent> ie <Plug>CamelCaseMotion_ie
omap <silent> ib <Plug>CamelCaseMotion_ib
xmap <silent> ib <Plug>CamelCaseMotion_ib
" }}}
" ## CONTEXT.VIM {{{
packadd context.vim
" }}}
" ## CSS3 COLORESQUE ## {{{
packadd vim-css3-syntax
packadd vim-coloresque
" }}}
" ## PRETTIER ## {{{
packadd vim-prettier
nmap <Leader>py <Plug>(Prettier)
vmap <Leader>py <Plug>(PrettierPartial)
augroup prettier_auto_save
	au!
	autocmd! BufWritePre *.html,*.htm,*.ts,*.css,*.scss Prettier
augroup END
" }}}
" ## VIM-LSP/ASYNCOMPLETE ## {{{
packadd vim-lsp
packadd asyncomplete.vim
packadd asyncomplete-lsp.vim
packadd asyncomplete-emmet.vim
packadd vim-lsp-settings
set foldmethod=expr
              \ foldexpr=lsp#ui#vim#folding#foldexpr()
              \ foldtext=lsp#ui#vim#folding#foldtext()
imap <C-Space> <Plug>(asyncomplete_force_refresh)
set complete&
set completeopt=menuone,noinsert,preview
set infercase
set pumheight=7
set noshowfulltag
" set shortmess+=c

let g:lsp_diagnostics_echo_cursor=1
let g:lsp_diagnostics_float_cursor=1
let g_lsp_highlights_enabled=1
let g:asyncompletet_auto_completeopt=0
let g:lsp_preview_float=1
let g:lsp_documentation_float_docked=1

inoremap <expr> <Down> pumvisible() ? "\<C-n>" : "\<Down>"
inoremap <expr> <Up> pumvisible() ? "\<C-p>" : "\<Up>"
inoremap <expr> <CR> pumvisible() ? asyncomplete#close_popup() : "\<CR>"
inoremap <expr> <TAB> pumvisible() ? asyncomplete#close_popup() : "\<TAB>"
inoremap <expr> <Left> pumvisible() ? asyncomplete#cancel_popup() : "\<Left>"
autocmd! CompleteDone ff if pumvisible() == 0 | pclose | endif

nnoremap <Leader>l. :LspCodeAction<CR>
nnoremap <Leader>l, :LspHover<CR>
nnoremap <Leader>lr :LspRename<CR>
nnoremap <Leader>ld :LspDefinition<CR>
nnoremap <Leader>ls :LspDocumentSymbolSearch<CR>
nnoremap <Leader>lS :LspWorkspaceSymbolSearch<CR>
nnoremap <Leader>lj :LspNextDiagnostic<CR>
nnoremap <Leader>lk :LspPreviousDiagnostic<CR>
nnoremap <Leader>ly :<C-u>LspDocumentFormat<CR>
vnoremap <Leader>lY :LspDocumentRangeFormat<CR>
" }}}
" ## QUICKPICK ## {{{
packadd quickpick.vim
packadd quickpick-lsp.vim
packadd quickpick-buffers.vim
packadd quickpick-fd.vim
nnoremap <Leader>lo :PLspDocumentSymbol<CR>
nnoremap <Leader>lO :PLspWorkspaceSymbol<CR>
nnoremap <Leader>o :PBuffers<CR>
nnoremap <Leader>p :Pfd<CR>
" }}}
" ## RIPGREP ## {{{
packadd vim-ripgrep
let g:rg_derive_root=1
let g:rg_root_types=['.git', 'node_modules','Cargo.toml','package.json']
let g:rg_highlight=1
nnoremap <Leader>f :Rg<Space>
  " }}}
" ## VIM-ROOTER ## {{{
packadd vim-rooter
let g:rooter_patterns=['package.json','Cargo.toml','node_modules','.git']

" }}}
" ## VIM-TEST ## {{{
  packadd vim-test
  nmap <silent> <Leader>t :TestNearest
  " }}}
" ## VIM-TEXTOBJ ## {{{
packadd vim-textobj-user
packadd vim-textobj-css
packadd vim-textobj-function
packadd vim-textobj-function-javascript
" }}}

set background=light
colorscheme base16-windows-95-light

" ## GIT-BRANCH ## {{{
function! GitBranchName() abort
  if get(b:, 'gitbranch_pwd', '') !=# expand('%:p:h') || !has_key(b:, 'gitbranch_path')
    call GitBranchDetect(expand('%:p:h'))
  endif
  if has_key(b:, 'gitbranch_path') && filereadable(b:gitbranch_path)
    let branch = get(readfile(b:gitbranch_path), 0, '')
    if branch =~# '^ref: '
      return substitute(branch, '^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
    elseif branch =~# '^\x\{20}'
      return branch[:6]
    endif
  endif
  return ''
endfunction

function! GitBranchDir(path) abort
  let path = a:path
  let prev = ''
  let git_modules = path =~# '/\.git/modules/'
  while path !=# prev
    let dir = path . '/.git'
    let type = getftype(dir)
    if type ==# 'dir' && isdirectory(dir . '/objects') && isdirectory(dir . '/refs') && getfsize(dir . '/HEAD') > 10
      return dir
    elseif type ==# 'file'
      let reldir = get(readfile(dir), 0, '')
      if reldir =~# '^gitdir: '
        return simplify(path, '/', reldir[8:])
      endif
    elseif git_modules && isdirectory(dir . '/objects') && isdirectory(dir . '/refs') && getfsize(dir . '/HEAD') > 10
      return path
    endif
    let prev = path
    let path = fnamemodify(path, ':h')
  endwhile
  return ''
endfunction

function! GitBranchDetect(path) abort
  unlet! b:gitbranch_path
  let b:gitbranch_pwd = expand('%:p:h')
  let dir = GitBranchDir(a:path)
  if dir !=# ''
    let path = dir . '/HEAD'
    if filereadable(path)
      let b:gitbranch_path = path
    endif
  endif
endfunction
 
" }}}
" ## STATUSBAR ## {{{
let g:mode_colors = {
      \ 'n': 'StatusLineSection',
      \ 'v': 'StatusLineSectionV',
      \ '': 'StatusLineSectionV',
      \ 'i': 'StatusLineSectionI',
      \ 'c': 'StatusLineSectionC',
      \ 'r': 'StatusLineSectionR',
      \ }

let g:mode_labels= {
      \'n': 'NORMAL', 'i': 'INSERT', 'R': 'REPLACE', 'v': 'VISUAL', 'V': 'V-LINE', "\<C-v>": 'V-BLOCK',
      \     'c': 'COMMAND', 's': 'SELECT', 'S': 'S-LINE', "\<C-s>": 'S-BLOCK', 't': 'TERMINAL'
      \ }

fun! StatusLineRenderer()
  let mode_label = get(g:mode_labels, tolower(mode()), g:mode_labels.n)
  let git_branch_name = GitBranchName()
  let hl = '%#' . get(g:mode_colors, tolower(mode()), g:mode_colors.n) . '#'
  return hl
        \ . ' ' . mode_label . ' '
        \ . '%#StatusLine#% '
        \ . ' ' . (len(git_branch_name) > 1 ? git_branch_name .'|' : '')
        \ . '%t%m'
        \ . '%#StatusLine#%='
        \ . '%y %l:%c(%p%%)'
  "return hl . GitBranchName() . ' %{StatusLineFilename()}%m%y %#StatusLine#%=' . hl . ' %l:%c %p'
endfun

fun! StatusLineFilename()
  if (&ft ==? 'netrw') | return '*' | endif
  return substitute(expand('%'), '^' . getcwd() . '/\?', '', 'i')
endfun

fun! <SID>StatusLineHighlights()
  hi StatusLine         ctermbg=8  guibg=#313131 ctermfg=15 guifg=#cccccc
  hi StatusLineNC       ctermbg=0  guibg=#313131 ctermfg=8  guifg=#999999
  hi StatusLineSection  ctermbg=8  guibg=#55b5db ctermfg=0  guifg=#FFFFFF gui=bold
  hi StatusLineSectionV ctermbg=11 guibg=#a074c4 ctermfg=0  guifg=#FFFFFF gui=bold
  hi StatusLineSectionI ctermbg=10 guibg=#9fca56 ctermfg=0  guifg=#FFFFFF gui=bold
  hi StatusLineSectionC ctermbg=12 guibg=#db7b55 ctermfg=0  guifg=#FFFFFF gui=bold
  hi StatusLineSectionR ctermbg=12 guibg=#ed3f45 ctermfg=0  guifg=#FFFFFF gui=bold
endfun

call <SID>StatusLineHighlights()

if has('vim_starting')
  let &statusline = ' %{StatusLineFilename())%= %l:%c'
endif

augroup vimrc
  au!
  au FocusGained,VimEnter,WinEnter,BufWinEnter * setlocal statusline=%!StatusLineRenderer()
  au FocusLost,VimLeave,WinLeave,BufWinLeave * setlocal statusline&
  au Colorscheme * call <SID>StatusLineHighlights()
augroup END
" }}}

nnoremap <Leader>cd :cd %:p:h<CR>

set spell
set spelllang=en_us,sv,cjk

set langmenu=en_US
let $LANG = 'en_US'
source $VIMRUNTIME/delmenu.vim
source $VIMRUNTIME/menu.vim

set noeb vb t_vb=
au GUIEnter * set vb t_vb=
" vim: set sw=2 ts=2 sts=2 et tw=78 foldmarker={{{,}}} foldmethod=marker:
